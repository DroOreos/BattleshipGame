

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.stage.Stage;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Pos;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.animation.PathTransition;
import javafx.util.Duration;
import model.Gameboard;
import model.GridCell;
import model.Ship;
import model.theBattleShipGame;

import java.lang.reflect.Array;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Observable;
import java.util.Observer;

import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.paint.ImagePattern;
import javafx.scene.layout.BorderPane;
import javafx.scene.shape.Path;

//import import javafx.scene.

public class BattleShipView extends BorderPane implements Observer {

//	private theBattleShipGame theGame;
	private Image waterCell_Image;
	private ImageView rocket_Image;
	private Image hit_Image;
	private Image miss_Image;

	private ArrayList<Ship> player_ships;
	private ArrayList<Ship> opponent_ships;

	// keep track of the ship being dragged.
	private Ship selectedShip = null;

	// ALL Battleships Horizontal
	private Image aircraft_h; // 5 spaces
	private Image battleship_h; // 4 spaces
	private Image cruiser_h; // 3 spaces
	private Image submarine_h; // 3 spaces
	private Image destroyer_h; // 2 spaces

	// ALL Battleships Vertical
	private Image aircraft_v; // 5 spaces
	private Image battleship_v; // 4 spaces
	private Image cruiser_v; // 3 spaces
	private Image submarine_v; // 3 spaces
	private Image destroyer_v; // 2 spaces

	private static final int BOARD_WIDTH = 500; // 50 pixels per cell * 10 columns
	private static final int BOARD_HEIGHT = 300; // 30 pixels per cell * 10 rows
	private static final int BOARD_ROWS = 10;
	private static final int BOARD_COLS = 10;
	private static final int CELL_WIDTH = BOARD_WIDTH / BOARD_COLS;
	private static final int CELL_HEIGHT = BOARD_HEIGHT / BOARD_ROWS;

	// 0 --> 9
	private int location_x;
	private int location_y;

	// pixels of the location
	private int rowCell_coordinate;
	private int colCell_coordinate;

	Pane opponentPane;

	private static final double rocketX = 0;
	private static final double rocketY = 500;

	private Canvas playerBoardCanvas = new Canvas(BOARD_WIDTH, BOARD_HEIGHT);
	private Canvas opponentBoardCanvas = new Canvas(BOARD_WIDTH, BOARD_HEIGHT);

	private GridCell[][] playerB;
	private GridCell[][] opponentB;

	private theBattleShipGame theGame;

	/**
	 * Constructor
	 * 
	 * @param theGame - current state of the battleship game
	 */
	public BattleShipView(theBattleShipGame theGame) {
		this.theGame = theGame;
		initializeBackround();

		initializeAllPanel();

		initializeImages();

		initializeRocket();

		setUpPlayerShips();

		//handlers();
	}


	private void initializeBackround() {
		try {

			// Load the background image
			// URL backgroundImageUrl = new
			// URL("https://imagedelivery.net/9sCnq8t6WEGNay0RAQNdvQ/UUID-cl90h85qq3675379tqywsvb6z1w/public");
			URL backgroundImageUrl = new URL(
					"https://c4.wallpaperflare.com/wallpaper/965/883/624/manga-one-piece-wallpaper-preview.jpg");
			Image backgroundImage = new Image(backgroundImageUrl.toString());

			ImagePattern imagePattern = new ImagePattern(backgroundImage);

			// Set the ImagePattern as the background for the BorderPane
			this.setBackground(new Background(new BackgroundFill(imagePattern, null, null)));
		} catch (MalformedURLException e) {
			e.printStackTrace();
		}
	}

	private void initializeAllPanel() {
		this.setTop(getOpponentBoardCanvas());
		this.setBottom(getPlayerBoardCanvas());

		this.setAlignment(getOpponentBoardCanvas(), Pos.BOTTOM_CENTER);
		this.setAlignment(getPlayerBoardCanvas(), Pos.TOP_CENTER);
		try {
			// Load the water image
			URL imageUrl = new URL("https://thumbs.dreamstime.com/b/pixel-art-water-pool-background-213938739.jpg");

			waterCell_Image = new Image(imageUrl.toString());

			setCells(getOpponentBoardCanvas());
			setCells(getPlayerBoardCanvas());
		} catch (MalformedURLException e) {
			e.printStackTrace();
		}

		drawB(getOpponentBoardCanvas());
		drawB(getPlayerBoardCanvas());
	}

	private void initializeImages() {

		// FOR TESTING
		// getCellPixels(0,0);
		// gc.drawImage(hit_Image, rowCell_coordinate, colCell_coordinate, CELL_WIDTH,
		// CELL_HEIGHT);

		try {

			GraphicsContext gc = getPlayerBoardCanvas().getGraphicsContext2D();
			URL hit = new URL("https://image.pngaaa.com/588/355588-middle.png");
			hit_Image = new Image(hit.toString());

			URL miss = new URL(
					"https://c4.wallpaperflare.com/wallpaper/965/883/624/manga-one-piece-wallpaper-preview.jpg");
			miss_Image = new Image(miss.toString());

			// ALL SHIP Images Declared Here
			URL ship1 = new URL(
					"https://img.favpng.com/4/14/5/ship-aircraft-carrier-united-states-navy-clip-art-png-favpng-YJvtPmWSFN7q50g50bnHU53j2.jpg");
			aircraft_h = new Image(ship1.toString());

			URL ship2 = new URL(
					"https://creazilla-store.fra1.digitaloceanspaces.com/cliparts/3868258/battleship-clipart-md.png");
			battleship_h = new Image(ship2.toString());

			URL ship3 = new URL(
					"https://static.vecteezy.com/system/resources/thumbnails/019/007/990/small/yacht-cruise-ship-png.png");
			cruiser_h = new Image(ship3.toString());

			URL ship4 = new URL(
					"https://p.turbosquid.com/ts-thumb/iS/z7mXc9/3l/submarine_oceangate_titan/jpg/1637404259/1920x1080/turn_fit_q99/96ecaa6f68c7e9fb1881b7c070c3134479f33dad/submarine_oceangate_titan-1.jpg");
			submarine_h = new Image(ship4.toString());

			URL ship5 = new URL("https://cdn.pixabay.com/photo/2020/08/28/01/58/raft-5523297_1280.png");
			destroyer_h = new Image(ship5.toString());

			ship1 = new URL(
					"https://img.favpng.com/4/14/5/ship-aircraft-carrier-united-states-navy-clip-art-png-favpng-YJvtPmWSFN7q50g50bnHU53j2.jpg");
			aircraft_v = new Image(ship1.toString());

			ship2 = new URL(
					"https://creazilla-store.fra1.digitaloceanspaces.com/cliparts/3868258/battleship-clipart-md.png");
			battleship_v = new Image(ship2.toString());

			ship3 = new URL(
					"https://static.vecteezy.com/system/resources/thumbnails/019/007/990/small/yacht-cruise-ship-png.png");
			cruiser_v = new Image(ship3.toString());

			ship4 = new URL(
					"https://p.turbosquid.com/ts-thumb/iS/z7mXc9/3l/submarine_oceangate_titan/jpg/1637404259/1920x1080/turn_fit_q99/96ecaa6f68c7e9fb1881b7c070c3134479f33dad/submarine_oceangate_titan-1.jpg");
			submarine_v = new Image(ship4.toString());

			ship5 = new URL("https://cdn.pixabay.com/photo/2020/08/28/01/58/raft-5523297_1280.png");
			destroyer_v = new Image(ship5.toString());

		} catch (MalformedURLException e) {
			e.printStackTrace();
		}
	}

	private void initializeRocket() {
		try {
			// Load the rocket image from the URL
			URL imageUrl = new URL(
					"https://www.kindpng.com/picc/m/179-1797286_ufo-png-pixel-walking-dead-pixel-art-transparent.png");

			Image rocketImage = new Image(imageUrl.toString());

			// Create the rocket here
			rocket_Image = new ImageView(rocketImage);
			rocket_Image.relocate(rocketX, rocketY);

			rocket_Image.setFitWidth(CELL_WIDTH);
			rocket_Image.setFitHeight(CELL_HEIGHT);

			opponentPane = new Pane(getOpponentBoardCanvas(), rocket_Image);
			setCenter(opponentPane);
			this.setAlignment(opponentPane, Pos.CENTER);
		} catch (MalformedURLException e) {
			e.printStackTrace();
		}
	}

	private void setUpPlayerShips() {

	}

//-----------------------------HELPER FUNCTIONS--------------------
	private void drawB(Canvas board) {
		GraphicsContext gc = board.getGraphicsContext2D();

		// Draw the grid lines.
		gc.setStroke(Color.BLACK);
		for (int row = 0; row <= BOARD_ROWS; row++) {
			double y = row * CELL_HEIGHT;
			gc.strokeLine(0, y, BOARD_WIDTH, y);
		}
		for (int col = 0; col <= BOARD_COLS; col++) {
			double x = col * CELL_WIDTH;
			gc.strokeLine(x, 0, x, BOARD_HEIGHT);
		}

	}

	private void setCells(Canvas board) throws MalformedURLException {
		GraphicsContext gc = board.getGraphicsContext2D();

		for (int row = 0; row < BOARD_ROWS; row++) {
			for (int col = 0; col < BOARD_COLS; col++) {
				double x = col * CELL_WIDTH;
				double y = row * CELL_HEIGHT;
				gc.drawImage(waterCell_Image, x, y, CELL_WIDTH, CELL_HEIGHT);
			}
		}
	}
	/**
	 * Change from 0-9 to the pixels of location
	 * 
	 * @param row
	 * @param col
	 */
	private void getCellPixels(int row, int col) {

		rowCell_coordinate = col * CELL_WIDTH;
		colCell_coordinate = row * CELL_HEIGHT;

	}
//-----------------------------------------------------------------
//--------------------------OBSERVRER( update game)-----------------
	

	@Override
	public void update(Observable o, Object arg) {

		
		// PLAYER GRIDCELLS
		playerB = theGame.get_playerB().getGrid();
		GraphicsContext gc = getPlayerBoardCanvas().getGraphicsContext2D();

		for (int i = 0; i < playerB.length; i++) {

			for (int j = 0; j < playerB[i].length; j++) {
				getCellPixels(i, j);

				switch (playerB[i][j].getState()) {

				case HIT:
					gc.drawImage(hit_Image, rowCell_coordinate, colCell_coordinate, CELL_WIDTH, CELL_HEIGHT);
					break;

				case MISS:
					gc.drawImage(miss_Image, rowCell_coordinate, colCell_coordinate, CELL_WIDTH, CELL_HEIGHT);
					break;
				}
			}
		}
		
		
		opponentB = theGame.get_opponentB().getGrid();
		gc = getOpponentBoardCanvas().getGraphicsContext2D();

		for (int i = 0; i < opponentB.length; i++) {

			for (int j = 0; j < opponentB[i].length; j++) {
				getCellPixels(i, j);

				switch (playerB[i][j].getState()) {

				case HIT:
					gc.drawImage(hit_Image, rowCell_coordinate, colCell_coordinate, CELL_WIDTH, CELL_HEIGHT);
					break;

				case MISS:
					gc.drawImage(miss_Image, rowCell_coordinate, colCell_coordinate, CELL_WIDTH, CELL_HEIGHT);
					break;
				}
			}
		}
		
		
	}


	public Canvas getPlayerBoardCanvas() {
		return playerBoardCanvas;
	}


	public void setPlayerBoardCanvas(Canvas playerBoardCanvas) {
		this.playerBoardCanvas = playerBoardCanvas;
	}


	public Canvas getOpponentBoardCanvas() {
		return opponentBoardCanvas;
	}


	public void setOpponentBoardCanvas(Canvas opponentBoardCanvas) {
		this.opponentBoardCanvas = opponentBoardCanvas;
	}

	
//------------------------------------------------------------------
	
	/*
	
	private void handlers() {
		opponentBoardCanvas.setOnMouseClicked(new MouseListener_attacking());

		// opponentBoardCanvas.setOnMouseClicked(new MouseListener());
		playerBoardCanvas.setOnMouseClicked(new MouseListner_placeShips());
	}
	private class MouseListner_placeShips implements EventHandler<MouseEvent>{

		@Override
		public void handle(MouseEvent me) {
			// TODO Auto-generated method stub
			double row = me.getY();
			double col =me.getX();
			System.out.println("("+row+", "+col + ") ");
				
				
			int moveRow = -1;
			int moveCol = -1;
						

			//determine selected ROW and COL for 

			//determine selected ROW
			if(row>=canvasBOTTOM && row<=CELL_WIDTH) 
				moveRow = 0;
			if(row>=CELL_WIDTH && row<=(CELL_WIDTH*2)) 
				moveRow = 1;
			if(row>=(CELL_WIDTH*2) && row<=(CELL_WIDTH*3)) 
				moveRow = 2;
			if(row>=(CELL_WIDTH*3) && row<=(CELL_WIDTH*4)) 
				moveRow = 3;
			if(row>=(CELL_WIDTH*4) && row<=(CELL_WIDTH*5)) 
				moveRow = 4;
			if(row>=(CELL_WIDTH*5) && row<=(CELL_WIDTH*6)) 
				moveRow = 5;
			if(row>=(CELL_WIDTH*6) && row<=(CELL_WIDTH*7)) 
				moveRow = 6;
			if(row>=(CELL_WIDTH*7) && row<=(CELL_WIDTH*8)) 
				moveRow = 7;
			if(row>=(CELL_WIDTH*8) && row<=(CELL_WIDTH*9)) 
				moveRow = 8;
			if(row>=(CELL_WIDTH*9) && row<=(CELL_WIDTH*10)) 
				moveRow = 9;
			
			//determine selected COL
			if(col>=canvasBOTTOM && col<CELL_HEIGHT) 
				moveCol = 0;
			if(col>=CELL_HEIGHT && col<=(CELL_HEIGHT*2)) 
				moveCol = 1;
			if(col>=(CELL_HEIGHT*2) && col<=(CELL_HEIGHT*3)) 
				moveCol = 2;
			if(col>=(CELL_HEIGHT*3) && col<=(CELL_HEIGHT*4)) 
				moveCol = 3;
			if(col>=(CELL_HEIGHT*4) && col<=(CELL_HEIGHT*5)) 
				moveCol = 4;
			if(col>=(CELL_HEIGHT*5) && col<=(CELL_HEIGHT*6)) 
				moveCol = 5;
			if(col>=(CELL_HEIGHT*6) && col<=(CELL_HEIGHT*7)) 
				moveCol = 6;
			if(col>=(CELL_HEIGHT*7) && col<=(CELL_HEIGHT*8)) 
				moveCol = 7;
			if(col>=(CELL_HEIGHT*8) && col<=(CELL_HEIGHT*9)) 
				moveCol = 8;
			if(col>=(CELL_HEIGHT*9) && col<=(CELL_HEIGHT*10)) 
				moveCol = 9;
			
			
			//facing west
			if(me.getButton().equals(MouseButton.SECONDARY)){
				theGame.getHumanPlayer().addShip(moveRow,moveCol,false,theGame.getHumanPlayer().lengthOfShip[theGame.getHumanPlayer().getNum_shipsAlive()]);

	        }
			//facing upright
			else {
				theGame.getHumanPlayer().addShip(moveRow,moveCol,true,theGame.getHumanPlayer().lengthOfShip[theGame.getHumanPlayer().getNum_shipsAlive()]);
			}
				
		}	
		 
		
	}


	private class MouseListener_attacking implements EventHandler<MouseEvent> {

		@Override
		public void handle(MouseEvent me) {
			// Get the pixel where the canvas was just clicked
			// TODO Auto-generated method stub
			double row = me.getY();
			double col =me.getX();
			System.out.println("("+row+", "+col + ") ");
			
			
			int moveRow = -1;
			int moveCol = -1;

			
			//determine selected ROW and COL for 

			//determine selected ROW
			if(row>=canvasTOP && row<=CELL_WIDTH) 
				moveRow = 0;
			if(row>=CELL_WIDTH && row<=(CELL_WIDTH*2)) 
				moveRow = 1;
			if(row>=(CELL_WIDTH*2) && row<=(CELL_WIDTH*3)) 
				moveRow = 2;
			if(row>=(CELL_WIDTH*3) && row<=(CELL_WIDTH*4)) 
				moveRow = 3;
			if(row>=(CELL_WIDTH*4) && row<=(CELL_WIDTH*5)) 
				moveRow = 4;
			if(row>=(CELL_WIDTH*5) && row<=(CELL_WIDTH*6)) 
				moveRow = 5;
			if(row>=(CELL_WIDTH*6) && row<=(CELL_WIDTH*7)) 
				moveRow = 6;
			if(row>=(CELL_WIDTH*7) && row<=(CELL_WIDTH*8)) 
				moveRow = 7;
			if(row>=(CELL_WIDTH*8) && row<=(CELL_WIDTH*9)) 
				moveRow = 8;
			if(row>=(CELL_WIDTH*9) && row<=(CELL_WIDTH*10)) 
				moveRow = 9;
			
			//determine selected COL
			if(col>=canvasTOP && col<CELL_HEIGHT) 
				moveCol = 0;
			if(col>=CELL_HEIGHT && col<=(CELL_HEIGHT*2)) 
				moveCol = 1;
			if(col>=(CELL_HEIGHT*2) && col<=(CELL_HEIGHT*3)) 
				moveCol = 2;
			if(col>=(CELL_HEIGHT*3) && col<=(CELL_HEIGHT*4)) 
				moveCol = 3;
			if(col>=(CELL_HEIGHT*4) && col<=(CELL_HEIGHT*5)) 
				moveCol = 4;
			if(col>=(CELL_HEIGHT*5) && col<=(CELL_HEIGHT*6)) 
				moveCol = 5;
			if(col>=(CELL_HEIGHT*6) && col<=(CELL_HEIGHT*7)) 
				moveCol = 6;
			if(col>=(CELL_HEIGHT*7) && col<=(CELL_HEIGHT*8)) 
				moveCol = 7;
			if(col>=(CELL_HEIGHT*8) && col<=(CELL_HEIGHT*9)) 
				moveCol = 8;
			if(col>=(CELL_HEIGHT*9) && col<=(CELL_HEIGHT*10)) 
				moveCol = 9;
		
			
			//Getting the cell
			GridCell selectedCell= player_grid[moveRow][moveCol];
			if(selectedCell.getState()==GridCell.CellState.EMPTY) {
				//signal change in gameboardGUI
				theGame.shoot(moveRow, moveCol);
				selectedCell.setState(GridCell.CellState.MISS);
				
			}
			if(selectedCell.getState()==GridCell.CellState.SHIP) {
				//signal change in gameboardGUI
				Ship[] AIshipArr = theGame.getAIPlayer().getShipArr();
				selectedCell.setState(GridCell.CellState.HIT);
				theGame.shoot(moveRow, moveCol);
				
			}		

			animateRocket(col, row);
		}

		private void animateRocket(double targetX, double targetY) {

			double grid_row = opponentBoardCanvas.localToScene(targetX, targetY).getX();
			double grid_col = opponentBoardCanvas.localToScene(targetX, targetY).getY();

			// Create a Path with LineTo elements for the rocket animation
			Path path = new Path();
			path.getElements().add(new MoveTo(rocketX, rocketY));
			path.getElements().add(new LineTo(grid_row, grid_col - 500));
			path.getElements().add(new LineTo(50, 100));

			// Create a PathTransition to animate the rocket
			PathTransition pT = new PathTransition();
			pT.setDuration(Duration.millis(4000));
			pT.setNode(rocket_Image);
			pT.setPath(path);

			// Start the rocket animation
			pT.play();
		}

	}

*/

}
