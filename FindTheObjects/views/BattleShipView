import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.stage.Stage;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Pos;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.animation.PathTransition;
import javafx.util.Duration;
import model.Gameboard;
import model.GridCell;
import model.Ship;
import model.theBattleShipGame;

import java.lang.reflect.Array;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;

import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.paint.ImagePattern;
import javafx.scene.layout.BorderPane;
import javafx.scene.shape.Path;
import model.Observer;

//import import javafx.scene.

public class BattleShipView extends BorderPane implements Observer {

//	private theBattleShipGame theGame;
	private Image waterCell_Image;
	private ImageView rocket_Image;
	private Image hit_Image;
	private Image miss_Image;

	private ArrayList<Ship> player_ships;
	private ArrayList<Ship> opponent_ships;

	// keep track of the ship being dragged.
	private Ship selectedShip = null;

	// ALL Battleships Horizontal
	private Image aircraft_h; // 5 spaces
	private Image battleship_h; // 4 spaces
	private Image cruiser_h; // 3 spaces
	private Image submarine_h; // 3 spaces
	private Image destroyer_h; // 2 spaces

	// ALL Battleships Vertical
	private Image aircraft_v; // 5 spaces
	private Image battleship_v; // 4 spaces
	private Image cruiser_v; // 3 spaces
	private Image submarine_v; // 3 spaces
	private Image destroyer_v; // 2 spaces

	Image[] shipImages;

	private static final int BOARD_WIDTH = 500; // 50 pixels per cell * 10 columns
	private static final int BOARD_HEIGHT = 300; // 30 pixels per cell * 10 rows
	private static final int BOARD_ROWS = 10;
	private static final int BOARD_COLS = 10;
	private static final int CELL_WIDTH = BOARD_WIDTH / BOARD_COLS;
	private static final int CELL_HEIGHT = BOARD_HEIGHT / BOARD_ROWS;

	// 0 --> 9
	private int location_x;
	private int location_y;

	// pixels of the location
	private int rowCell_coordinate;
	private int colCell_coordinate;

	Pane opponentPane;

	private static final double rocketX = 0;
	private static final double rocketY = 500;

	private Canvas playerBoardCanvas = new Canvas(BOARD_WIDTH, BOARD_HEIGHT);
	private Canvas opponentBoardCanvas = new Canvas(BOARD_WIDTH, BOARD_HEIGHT);

	private GridCell[][] playerB;
	private GridCell[][] opponentB;

	private ArrayList<ArrayList<Integer>> playerShips = new ArrayList<>();
	// private ArrayList<>

	private theBattleShipGame theGame;

	/**
	 * Constructor
	 * 
	 * @param theGame - current state of the battleship game
	 */
	public BattleShipView(theBattleShipGame theGame) {
		this.theGame = theGame;
		theGame.addObserver(this);
		initializeBackround();

		initializeAllPanel();

		initializeImages();

		initializeRocket();

		setUpPlayerShips();

		handlers();
	}

	private void initializeBackround() {
		try {

			// Load the background image
			// URL backgroundImageUrl = new
			// URL("https://imagedelivery.net/9sCnq8t6WEGNay0RAQNdvQ/UUID-cl90h85qq3675379tqywsvb6z1w/public");
			URL backgroundImageUrl = new URL(
					"https://c4.wallpaperflare.com/wallpaper/965/883/624/manga-one-piece-wallpaper-preview.jpg");
			Image backgroundImage = new Image(backgroundImageUrl.toString());

			ImagePattern imagePattern = new ImagePattern(backgroundImage);

			// Set the ImagePattern as the background for the BorderPane
			this.setBackground(new Background(new BackgroundFill(imagePattern, null, null)));
		} catch (MalformedURLException e) {
			e.printStackTrace();
		}
	}

	private void initializeAllPanel() {
		this.setTop(getOpponentBoardCanvas());
		this.setBottom(getPlayerBoardCanvas());

		this.setAlignment(getOpponentBoardCanvas(), Pos.BOTTOM_CENTER);
		this.setAlignment(getPlayerBoardCanvas(), Pos.TOP_CENTER);
		try {
			// Load the water image
			URL imageUrl = new URL("https://thumbs.dreamstime.com/b/pixel-art-water-pool-background-213938739.jpg");

			waterCell_Image = new Image(imageUrl.toString());

			setCells(getOpponentBoardCanvas());
			setCells(getPlayerBoardCanvas());
		} catch (MalformedURLException e) {
			e.printStackTrace();
		}

		drawB(getOpponentBoardCanvas());
		drawB(getPlayerBoardCanvas());
	}

	private void initializeImages() {
		shipImages = new Image[5];

		try {
			URL hit = new URL("https://png.pngtree.com/png-clipart/20190416/ourmid/pngtree-fire-flame-blast-png-png-image_946469.jpg");
			hit_Image = new Image(hit.toString());

			URL miss = new URL(
					"https://previews.123rf.com/images/the8monkey/the8monkey2005/the8monkey200500135/147458470-vector-frame-water-splash-for-game-animation-water-explosion-special-effect-fx-animation-frame-on.jpg");
			miss_Image = new Image(miss.toString());

			// ALL SHIP Images Declared Here
			URL ship1 = new URL(
					"https://img.favpng.com/4/14/5/ship-aircraft-carrier-united-states-navy-clip-art-png-favpng-YJvtPmWSFN7q50g50bnHU53j2.jpg");
			shipImages[0] = new Image(ship1.toString());

			URL ship2 = new URL(
					"https://creazilla-store.fra1.digitaloceanspaces.com/cliparts/3868258/battleship-clipart-md.png");
			shipImages[1] = new Image(ship2.toString());

			URL ship3 = new URL(
					"https://static.vecteezy.com/system/resources/thumbnails/019/007/990/small/yacht-cruise-ship-png.png");
			shipImages[2] = new Image(ship3.toString());

			URL ship4 = new URL(
					"https://p.turbosquid.com/ts-thumb/iS/z7mXc9/3l/submarine_oceangate_titan/jpg/1637404259/1920x1080/turn_fit_q99/96ecaa6f68c7e9fb1881b7c070c3134479f33dad/submarine_oceangate_titan-1.jpg");
			shipImages[3] = new Image(ship4.toString());

			URL ship5 = new URL("https://cdn.pixabay.com/photo/2020/08/28/01/58/raft-5523297_1280.png");
			shipImages[4] = new Image(ship5.toString());

		} catch (MalformedURLException e) {
			e.printStackTrace();
		}
	}

	private void initializeRocket() {
		try {
			// Load the rocket image from the URL
			URL imageUrl = new URL(
					"https://www.kindpng.com/picc/m/179-1797286_ufo-png-pixel-walking-dead-pixel-art-transparent.png");

			Image rocketImage = new Image(imageUrl.toString());

			// Create the rocket here
			rocket_Image = new ImageView(rocketImage);
			rocket_Image.relocate(rocketX, rocketY);

			rocket_Image.setFitWidth(CELL_WIDTH);
			rocket_Image.setFitHeight(CELL_HEIGHT);

			opponentPane = new Pane(getOpponentBoardCanvas(), rocket_Image);
			setCenter(opponentPane);
			this.setAlignment(opponentPane, Pos.CENTER);
		} catch (MalformedURLException e) {
			e.printStackTrace();
		}
	}

	private void setUpPlayerShips() {

		theGame.placeAIShips();
		theGame.printAIBoard(theGame.get_opponentB());

		GraphicsContext gc = getPlayerBoardCanvas().getGraphicsContext2D();

		// default ships are placed
		theGame.getHumanPlayer().addShip(0, 0, false, 5);
		theGame.getHumanPlayer().addShip(1, 0, false, 4);
		theGame.getHumanPlayer().addShip(2, 0, false, 3);
		theGame.getHumanPlayer().addShip(3, 0, false, 3);
		theGame.getHumanPlayer().addShip(4, 0, false, 2);

		// ArrayList = ( x, y, vertical == 1, size, Image)
		playerShips.add(new ArrayList<>(Arrays.asList(0, 0, 0, 5, 0))); // Aircraft Carrier
		playerShips.add(new ArrayList<>(Arrays.asList(1, 0, 0, 4, 1))); // Battleship
		playerShips.add(new ArrayList<>(Arrays.asList(2, 0, 0, 3, 2))); // Submarine
		playerShips.add(new ArrayList<>(Arrays.asList(3, 0, 0, 3, 3))); // Cruiser
		playerShips.add(new ArrayList<>(Arrays.asList(4, 0, 0, 2, 4))); // Destroyer

		for (ArrayList<Integer> ship : playerShips) {
			int xStart = ship.get(0);
			int yStart = ship.get(1);

			int vertical = ship.get(2);
			int size = ship.get(3);
			int image = ship.get(4);

			getCellPixels(xStart, yStart);
			int width, height;

			if (vertical == 1) { // true
				width = CELL_WIDTH;
				height = CELL_HEIGHT * size;
			} else {
				width = CELL_WIDTH * size;
				height = CELL_HEIGHT;
			}

			gc.drawImage(shipImages[image], rowCell_coordinate, colCell_coordinate, width, height);
		}
	}

//-----------------------------HELPER FUNCTIONS--------------------
	private void drawB(Canvas board) {
		GraphicsContext gc = board.getGraphicsContext2D();

		// Draw the grid lines.
		gc.setStroke(Color.BLACK);
		for (int row = 0; row <= BOARD_ROWS; row++) {
			double y = row * CELL_HEIGHT;
			gc.strokeLine(0, y, BOARD_WIDTH, y);
		}
		for (int col = 0; col <= BOARD_COLS; col++) {
			double x = col * CELL_WIDTH;
			gc.strokeLine(x, 0, x, BOARD_HEIGHT);
		}

	}

	private void setCells(Canvas board) throws MalformedURLException {
		GraphicsContext gc = board.getGraphicsContext2D();

		for (int row = 0; row < BOARD_ROWS; row++) {
			for (int col = 0; col < BOARD_COLS; col++) {
				double x = col * CELL_WIDTH;
				double y = row * CELL_HEIGHT;
				gc.drawImage(waterCell_Image, x, y, CELL_WIDTH, CELL_HEIGHT);
			}
		}
	}

	/**
	 * Change from 0-9 to the pixels of location
	 * 
	 * @param row
	 * @param col
	 */
	private void getCellPixels(int row, int col) {

		rowCell_coordinate = col * CELL_WIDTH;
		colCell_coordinate = row * CELL_HEIGHT;

	}
//-----------------------------------------------------------------
//--------------------------OBSERVRER( update game)-----------------

	@Override
	public void update(Object theObserved) {
		// TODO Auto-generated method stub

		// PLAYER GRIDCELLS
		playerB = theGame.get_playerB().getGrid();
		GraphicsContext gc = getPlayerBoardCanvas().getGraphicsContext2D();
		
		updateBoard(playerB, gc);

		

		opponentB = theGame.get_opponentB().getGrid();
		gc = getOpponentBoardCanvas().getGraphicsContext2D();
		updateBoard(opponentB, gc);
	}
	
	private void updateBoard(GridCell[][] board, GraphicsContext gc) {
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[i].length; j++) {
				
				getCellPixels(i, j);

				switch (board[i][j].getState()) {

				case HIT:
					gc.drawImage(hit_Image, rowCell_coordinate, colCell_coordinate, CELL_WIDTH, CELL_HEIGHT);
					break;

				case MISS:
					gc.drawImage(miss_Image, rowCell_coordinate, colCell_coordinate, CELL_WIDTH, CELL_HEIGHT);
					break;
				}
			}
		}
	
}

	// ------------------------------------------------------------------

	public Canvas getPlayerBoardCanvas() {
		return playerBoardCanvas;
	}

	public void setPlayerBoardCanvas(Canvas playerBoardCanvas) {
		this.playerBoardCanvas = playerBoardCanvas;
	}

	public Canvas getOpponentBoardCanvas() {
		return opponentBoardCanvas;
	}

	public void setOpponentBoardCanvas(Canvas opponentBoardCanvas) {
		this.opponentBoardCanvas = opponentBoardCanvas;
	}

	public void handlers() {
		opponentBoardCanvas.setOnMouseClicked(new MouseListener_X());

		// opponentBoardCanvas.setOnMouseClicked(new MouseListener());
		// playerBoardCanvas.setOnMouseClicked(new MouseListner_placeShips());
	}

	private class MouseListener_X implements EventHandler<MouseEvent> {

		@Override
		public void handle(MouseEvent me) {
			// Get the pixel where the canvas was just clicked
			double row = me.getY();
			double col = me.getX();
			System.out.println("(we in here" + row + ", " + col + ") ");

			int r = (int) (row / CELL_HEIGHT);
			int c = (int) (col / CELL_WIDTH);
			GridCell selectedCell = theGame.get_playerB().getGridCell(r, c);

			if (selectedCell.getState() == GridCell.CellState.EMPTY
					|| selectedCell.getState() == GridCell.CellState.SHIP) {
				theGame.setPAttack(r, c);
				
				//System.out.println("sending attack to" + r + ", " + c + ") ");
				selectedCell.setState(GridCell.CellState.MISS);

			}
			animateRocket(col, row);
		}

		private void animateRocket(double targetX, double targetY) {

			double grid_row = opponentBoardCanvas.localToScene(targetX, targetY).getX();
			double grid_col = opponentBoardCanvas.localToScene(targetX, targetY).getY();

			// Create a Path with LineTo elements for the rocket animation
			Path path = new Path();
			path.getElements().add(new MoveTo(rocketX, rocketY));
			path.getElements().add(new LineTo(grid_row, grid_col - 500));
			path.getElements().add(new LineTo(50, 100));

			// Create a PathTransition to animate the rocket
			PathTransition pT = new PathTransition();
			pT.setDuration(Duration.millis(4000));
			pT.setNode(rocket_Image);
			pT.setPath(path);

			// Start the rocket animation
			pT.play();
		}

	}
}
